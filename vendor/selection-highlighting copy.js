(function() {
var SelectionHighlighting = function(args) {

  // Don't let an instance be created without a valid selectable container
  if (!args || !args.selectableContainerId ||
      !document.getElementById(args.selectableContainerId)
  ) {
    console.log('The id for the selectable container must be supplied to this object.');
    console.log('Please try again with: new SelectionHighlighting({ selectableContainerId: "theID" });');
    return null;
  }

  // Private variable declarations
  var highlighting = this,
    selections = [], // array of selection objects

    /*
     * Prefixes which are attached to the ids of various
     * elements generated by this library
     */
    highlightIdPrefix = args.idPrefix || 'enc-highlight-',
    heatIdPrefix = args.heatPrefix || 'heat-',

    /*
     * Whether or not to automatically create selections
     * on mouseup once the object is initialized
     */
    automaticallyRegisterEvent = args.automaticEvent !== undefined ? args.automaticEvent : true,

    /*
     * Id of the container element whose text can be selected
     */
    selectableContainerId = args.selectableContainerId,

    selectableContainer, // the element whose text can be selected
    nodeCoords = [], // array of coordinates of children of container
    textCoords = [], // array of coordinates of text within container
    textCoord = 0, // holds the length of the textCoords array
    allElementsHaveBeenIdentified = false, // flag if all children have id
    createdHeatMap = false, // flag if heatmap highlights on page
    selectionDisabled = false, // flag if selections not allowed to be made

    /*
     * Reference to the mouseup event for creating selections
     */
    selectableMouseup = function(event) {
      if (event.target.id.includes('img-tag')) {
        return;
      }
      highlighting.createSelection(highlighting.getId(), event, true);
    },

    handleConfirmButton = function(selectionObject) {
      let confirm = document.getElementById('confirm-text-sel');
      let coords = highlighting.getSelectionContainerCoords();
      let text;

      if (selectionObject) {
        text = selectionObject.toString();
      }

      if (coords === undefined || !text) {
        if (confirm) {
          confirm.remove();
        }

        return;
      }

      // there is text selected
      if (!confirm) {
        // create confirm button
        confirm = document.createElement('button');
        confirm.id = 'confirm-text-sel';
        confirm.innerText = 'Save Selection';
        confirm.className='primary-button ';
        confirm.style.zIndex = '200';

        confirm.addEventListener('click', function() {
          highlighting.createSelection(highlighting.getId(), event, true);
          confirm.remove();
        });

        let header = document.getElementById('selections-header');
        header.appendChild(confirm);
      }
    },

    handleSelectionChange = function() {
      if (selectionDisabled) {
        return;
      }

      handleConfirmButton(window.getSelection());
    },

    /*
     * Constants used throughout the library
     */
    ELEMENT_NODE = 1,
    TEXT_NODE = 3;

/*
 ***
 */

  // Object-context proxies for the static functions
  /**
   * ###### Public function getRange()
   * Returns the selection object associated with currently highlighted text
   */
  this.getRange = function() {
    return SelectionHighlighting.getRange();
  };
/*
 ***
 */

  /**
   * ###### Public function removeAllRanges()
   * Remove all range objects from the page, unselecting all text
   */
  this.removeAllRanges = function() {
    SelectionHighlighting.removeAllRanges();
  };
/*
 ***
 */

  /**
   * ###### Public function getMouseButton()
   * Returns the mouse button that generated the event
   * @param {Event} event The event whose mouse button is to be checked
   */
  this.getMouseButton = function(event) {
    return SelectionHighlighting.getMouseButton(event);
  };
/*
 ***
 */

  /**
   * ###### Public function selectCoords()
   * Select the text on the page associated with the given range coordinates
   * @param {string} coord The range coordinates to select within the page
   */
  this.selectCoords = function(coord) {
    return SelectionHighlighting.selectCoords(coord);
  };
/*
 ***
 */

  /**
   * ###### Public function getSelectedText()
   * Returns the selected text on the page
   */
  this.getSelectedText = function() {
    return SelectionHighlighting.getSelectedText();
  };
/*
 ***
 */

  /**
   * ###### Public static function getTextAt()
   * Gets the text on the page at the given coordinates
   * @param {string} coords The range coords whose text is to be retrieved
   */
  this.getTextAt = function(coords) {
    return SelectionHighlighting.getTextAt(coords);
  };
/*
 ***
 */

  /**
   * ###### Private function identifyElement()
   * Gives an element an id if it doesn't have one yet
   * @param {Node} node The node which is to receive an id, if possible
   * @param {number} num A unique number to add to the end of the id
   */
  function identifyElement(node, num) {
    var childNodes, nodesLength, i;

    if (node.nodeType !== ELEMENT_NODE) { // node that can't have an id
      return num;
    }

    if (!node.hasAttribute('id')) { // element doesn't have an id

      // increment num until an unused id can be produced
      while (document.getElementById('node-' + num)) {
        num += 1;
      }

      // give the element its new id and increment num
      node.setAttribute('id', 'node-' + num);
      num += 1;
    }

    // loop through all the element's children
    childNodes = node.childNodes;
    nodesLength = childNodes.length;
    for (i = 0; i < nodesLength; i += 1) {

      /*
       * recursively identify the element's children,
       * store the returned value in num
       */
      num = identifyElement(childNodes[i], num);
    }

    // return num so the caller knows how high the lowest id is
    return num;
  }
/*
 ***
 */

  /**
   * ###### Private function identifyAllElements()
   * Makes sure all children of selectableContainer have an id
   * @param {Element} ele The root element in the DOM subtree to identify
   * @param {number} num A unique number to add to the end of the id
   */
  function identifyAllElements(ele, num) {
    allElementsHaveBeenIdentified = false;
    identifyElement(ele, num);
    allElementsHaveBeenIdentified = true;
  }
/*
 ***
 */

  /**
   * ###### Private function mapRangeCoordToTextCoordRecursive()
   * @param {Node} node The node to check for text to put into the coordinates map
   */
  function mapRangeCoordToTextCoordRecursive(node) {
    var childNodes, nodesLength, childNode, i;

    /*
     * Tried storing the relationship between the nodes and text
     * coordinates in an associative array in the form
     * Array['{parentNode} {childNode}'] = textCoordinate
     * but that has issues with looping to find the names
     * of the keys and also isn't guaranteed to be in order.
     * Makes more sense to store the nodes and text coords
     * in separate arrays with corresponding indices to make
     * comparisons easier.
     */
    if (node.nodeType === ELEMENT_NODE) {
      childNodes = node.childNodes;
      nodesLength = childNodes.length;
      for (i = 0; i < nodesLength; i += 1) {
        childNode = childNodes[i];
        if (childNode.nodeType === TEXT_NODE) {
          /*
           * it's possible to get a lot of whitespace-only text nodes as a result
           * of formatting markup with tabs and newlines. we want to ignore those
           * so check if the text node contains something other than whitespace,
           * or if it is a single space, which we probably want to keep
           */
          if (childNode.nodeValue.match(/[^\r\n\t\f\v â†µ]/) || childNode.nodeValue === ' ') {
            // console.log('matched for node val: ', childNode.nodeValue, childNode.nodeValue.length);
            nodeCoords[nodeCoords.length] = (node.id + ' ' + i);
            textCoords[textCoords.length] = textCoord;
            textCoord += childNode.nodeValue.length;
          }
        } else if (childNode.nodeName.toLowerCase() === 'img') {
          nodeCoords[nodeCoords.length] = (node.id + ' ' + i);
          textCoords[textCoords.length] = textCoord;
          textCoord += 1;
        } else if (childNode.nodeType === ELEMENT_NODE) {
          mapRangeCoordToTextCoordRecursive(childNode);
        }
      }
    }
  }
/*
 ***
 */

  /**
   * ###### Private function mapRangeCoordToTextCoord()
   * Resets the mapping between range and text coordinates
   * @param {Element} ele The root element in the DOM subtree to map
   */
  function mapRangeCoordToTextCoord(ele) {
    nodeCoords = [];
    textCoords = [];
    textCoord = 0;
    mapRangeCoordToTextCoordRecursive(ele);
  }
/*
 ***
 */

  /**
   * ###### Private function getTextCoordFromRangeCoord()
   * Given a range coordinate, returns the corresponding text coordinate
   * @param {string} coord The range coordinate to convert to a text coordinate
   */
  function getTextCoordFromRangeCoord(coord) {
    var coords = coord.split(' '),
      startParent = coords[0], // id of the containing parent of the start of the selected text
      startChild  = coords[1], // number of siblings before text node
      startOffset = parseInt(coords[2], 10), // number of characters into text node before selected text starts
      endParent   = coords[3], // id of the containing parent of the end of the selected text
      endChild    = coords[4], // number of siblings before text node
      endOffset   = parseInt(coords[5], 10), // number of characters into the text node before selected text ends
      i, j, start, end, length = nodeCoords.length;

    // loop through and find the index of the start node within nodeCoords
    for (i = 0; i < length; i += 1) {
      if (nodeCoords[i] === (startParent + ' ' + startChild)) {

        // found the node, so add the start of the node and the offset
        start = textCoords[i] + startOffset;

        // starting with this node, loop through to find the end node's index within nodeCoords
        for (j = i; j < length; j += 1) {
          if (nodeCoords[j] === (endParent + ' ' + endChild)) {

            // found the node, so add the start of the node and the offset
            end = textCoords[j] + endOffset;

            // return the calculated text coordinates
            return { start: start, end: end };
          }
        }
      }
    }
  }
/*
 ***
 */

  /**
   * ###### Private function getRangeCoordFromTextCoord()
   * Given a text coordinate, returns the corresponding range coordinate
   * @param {number} start The offset at which to start the coordinates
   * @param {number} end The offset at which to end the coordinates
   */
  function getRangeCoordFromTextCoord(start, end) {
    var i, j, length = textCoords.length;

    // loop through textCoords and find the index of the section of text that `start` is in
    for (i = 0; i < length; i += 1) {
      if (start >= textCoords[i] && ((i < length - 1 && start < textCoords[i + 1]) || i === length - 1)) {

        // found the starting section of text, now need to find the ending section of text
        // starting with this section of text, loop through to find the section that `end` is in
        for (j = i; j < length; j += 1) {
          if (end >= textCoords[j] && ((j < length - 1 && end < textCoords[j + 1]) || j === length - 1)) {

            // found the ending section of text
            // return the full range coordinates
            return (nodeCoords[i] + ' ' + (start - textCoords[i]) + ' ' + nodeCoords[j] + ' ' + (end - textCoords[j]));
          }
        }
      }
    }
  }
/*
 ***
 */

  /**
   * ###### Private function getString()
   * Gets the substring within a node between `startOffset` and `endOffset`.
   * Calling with `endOffset = -1` gets the substring to the end of the node.
   * @param {Node} node The node from which to retrieve the string
   * @param {number} startOffset Start offset of the substring
   * @param {number} endOffset End offset of the substring
   */
  function getString(node, startOffset, endOffset) {

    // text node, so returning text
    if (node.nodeType === TEXT_NODE) {
      if (endOffset < 0) {
        endOffset = node.nodeValue.length;
      }
      return node.nodeValue.substring(startOffset, endOffset);
    }

    // image node, no text to return, so return "[img]"
    if (node.nodeName.toLowerCase() === 'img') {
      return '[img]';
    }

    // neither a text node or an image, return nothing
    return '';
  }
/*
 ***
 */

  /**
   * ###### Private function traverseSubTree()
   * Extracts the text value of a subtree of the DOM
   * @param {string} coord The coordinates of the start and end of the subtree
   * @param {Node} node A node within the subtree
   */
  function traverseSubTree(coord, node) {
    var coords = coord.split(' '),
      startParent = coords[0],
      startChild  = parseInt(coords[1], 10),
      startOffset = parseInt(coords[2], 10),
      endParent   = coords[3],
      endChild    = parseInt(coords[4], 10),
      endOffset   = parseInt(coords[5], 10),
      isFirstChild, string,
      childNodes, nodesLength, i;

    childNodes = node.childNodes;
    nodesLength = childNodes.length;

    // first, check if we have encountered the first branch in the subtree we want
    isFirstChild = false;
    if (node.parentNode.id === startParent && node === node.parentNode.childNodes[startChild]) {
      traverseSubTree.foundFirstChild = true;
      isFirstChild = true;
    }

    // only check if this is the end of the tree if the beginning was found
    if (traverseSubTree.foundFirstChild) {
      if (node.parentNode.id === endParent && node === node.parentNode.childNodes[endChild]) {
        traverseSubTree.foundFinalChild = true;
      }
    }

    // no children indicates a leaf of the subtree, so get the text
    if (nodesLength === 0) {

      // if this is the end, get only the text up to `endOffset`
      if (traverseSubTree.foundFinalChild) {
        return getString(node, 0, endOffset);
      }

      // we've begun searching within the correct subtree
      if (traverseSubTree.foundFirstChild) {

        // if this is the first leaf within the subtree, get the text
        // starting at `startOffset`, otherwise just get all of it
        return getString(node, (isFirstChild ? startOffset : 0), -1);
      }

      // haven't entered the subtree we want, so return empty string
      return '';
    }

    // container element, so step through its children,
    // concatenate all results, and return entire string
    string = '';
    for (i = 0; i < nodesLength; i += 1) {

      // make sure we stop searching if the last node has been found
      if (!traverseSubTree.foundFinalChild) {
        string += traverseSubTree(coord, childNodes[i]);
      } else {
        break;
      }
    }

    return string;
  }
/*
 ***
 */

  /**
   * ###### Private function buildStringFromRangeCoord()
   * Get the string representation of the nodes within the given coordinates
   * @param {string} coord The coordinates from which to get the string
   */
  function buildStringFromRangeCoord(coord) {
    highlighting.removeAllRanges();

    var coords = coord.split(' '),
      startParent = coords[0], // id of the containing parent of the start of the selected text
      startChild  = parseInt(coords[1], 10), // number of siblings before text node
      startOffset = parseInt(coords[2], 10), // number of characters into text node before selected text starts
      endParent   = coords[3], // id of the containing parent of the end of the selected text
      endChild    = parseInt(coords[4], 10), // number of siblings before text node
      endOffset   = parseInt(coords[5], 10), // number of characters into the text node before selected text ends
      node, commonAncestorContainer;

    // all the text lies within the same text node
    if (startParent === endParent && startChild === endChild) {
      node = document.getElementById(startParent).childNodes[startChild];
      return getString(node, startOffset, endOffset);
    }

    // select the range and get the common ancestor of the start and end nodes
    if (!highlighting.selectCoords(coord)) {
      return '';
    }
    commonAncestorContainer = highlighting.getRange().commonAncestorContainer;
    highlighting.removeAllRanges();

    // reset the flags for trimming the subtree and start searching
    traverseSubTree.foundFirstChild = false;
    traverseSubTree.foundFinalChild = false;
    return traverseSubTree(coord, commonAncestorContainer);
  }
/*
 ***
 */

  /**
   * ###### Private function getAllCoords()
   * Returns the coordinates of all the current selection objects
   */
  function getAllCoords() {
    var counter = 0, coords = [], selectionsLength, i;
    if (selections) {
      selectionsLength = selections.length;
    for (i = 0; i < selectionsLength; i += 1) {
      if (selections[i]) {
        coords[counter] = selections[i].coords;
        counter += 1;
      }
    }
    }


    return coords;
  }
/*
 ***
 */

  /**
   * ###### Private function findPosX()
   * Returns the horizontal pixel coordinates of an element on the page
   * @param {Node} node The node whose position is to be retrieved
   */
  function findPosX(node) {
    var curleft = 0;

    if (node.offsetParent) {
      while (node.offsetParent) {
        curleft += node.offsetLeft;
        node = node.offsetParent;
      }
    } else if (node.x) {
      curleft = node.x;
    }

    return curleft;
  }
/*
 ***
 */

  /**
   * ###### Private function findPosY()
   * Returns the vertical pixel coordinates of an element on the page
   * @param {Node} node The node whose position is to be retrieved
   */
  function findPosY(node) {
    var curtop = 0;

    if (node.offsetParent) {
      while (node.offsetParent) {
        curtop += node.offsetTop;
        node = node.offsetParent;
      }
    } else if (node.y) {
      curtop += node.y;
    }

    return curtop;
  }
/*
 ***
 */

  /**
   * ###### Private function getSelectionPixelCoords()
   * Returns the pixel coordinates and width and height of the
   *     area of text selected on the page
   */
  function getSelectionPixelCoords() {
    var sel = document.selection, range,
      x = 0, y = 0,
      w = 0, h = 0,
      rect, ele;

    if (sel) {
      if (sel.type !== 'Control') {
        range = sel.createRange();
        range.collapse(true);
        x = range.boundingLeft;
        y = range.boundingTop;
      }
    } else if (window.getSelection) {
      sel = window.getSelection();
      if (sel.rangeCount) {
        range = sel.getRangeAt(0).cloneRange();
        if (range.getClientRects) {
          rect = range.getClientRects()[0];
          x = rect.left;
          y = rect.top;
          w = rect.width;
          h = rect.height;
        }
      }
    }
    x += (document.body.scrollLeft || document.documentElement.scrollLeft);
    y += (document.body.scrollTop || document.documentElement.scrollTop);

    ele = selectableContainer;
    while (ele !== document.body) {
      x += ele.scrollLeft;
      y += ele.scrollTop;
      ele = ele.parentNode;
    }

    return { x: x, y: y, w: w, h: h };
  }
/*
 ***
 */

  /**
   * ###### Private function getZIndex()
   * Returns the zIndex of the given element
   * Used for placing highlights above an absolutely placed container
   * @param {Node} node The node whose relative z-index is to be retrieved
   */
  function getZIndex(node) {
    var zIndex;

    if (!node) {
      return 0;
    }

    if (window.getComputedStyle) {
      zIndex = document.defaultView.getComputedStyle(node, null).getPropertyValue('zIndex');
      if (!zIndex) {
        zIndex = document.defaultView.getComputedStyle(node, null).getPropertyValue('z-index');
      }
    } else if (node.currentStyle) {
      zIndex = node.currentStyle.zIndex;
    }

    if (zIndex !== 'auto' && zIndex !== 'inherit') {
      return zIndex;
    }
    if (node.parentNode && node !== document.body) {
      return getZIndex(node.parentNode);
    }
    return 1;
  }
/*
 ***
 */

  /**
   * ###### Private function placeHighlightAtPixelCoords()
   * Creates a highlight and places it on the page at given coordinates
   * @param {string} id Id to give to the highlight
   * @param {Object} coords Pixel coordinates at which to place the highlight
   * @param {string} bgColor Indicated the color to make this highlight
   */
  function placeHighlightAtPixelCoords(id, coords, bgColor) {
    var highlight, highlightStyles, style, zIndex;

    if (selectableContainer.style.position !== 'absolute') {
      selectableContainer.style.position = 'relative';
      coords.x -= findPosX(selectableContainer);
      coords.y -= findPosY(selectableContainer);
    } else {
      zIndex = getZIndex(selectableContainer);
    }

    highlight = document.createElement('div');
    highlight.id = highlightIdPrefix + id;

    highlightStyles = {
      position: 'absolute',
      // ratio is received as a decimal value representing the fraction of green to apply
      background: bgColor,
      top: coords.y + 'px',
      left: coords.x + 'px',
      height: coords.h + 'px',
      width: coords.w + 'px'
    };
    for (style in highlightStyles) {
      if (highlightStyles.hasOwnProperty(style)) {
        highlight.style[style] = highlightStyles[style];
      }
    }

    if (selectableContainer.style.position !== 'absolute') {
      selectableContainer.appendChild(highlight);
    } else {
      highlight.style.zIndex = zIndex;
      document.body.appendChild(highlight);
    }
  }
/*
 ***
 */

  /**
   * ###### Private function getRandomColor()
   * Returns a string representation of a random RGB
   */
  function getRandomColor() {
    var rgb = [], count = 3,
      i, j, tmp;

    // keep generating until we get a good color
    while (count > 2) {
      rgb[0] = Math.floor(Math.random() * 256);
      rgb[1] = Math.floor(Math.random() * 256);
      rgb[2] = Math.floor(Math.random() * 256);

      // if the values are too low, then the color
      // might be too light to clearly see
      count = 1;
      if (rgb[0] < 75 * count) { count++; }
      if (rgb[1] < 75 * count) { count++; }
      if (rgb[2] < 75 * count) { count++; }
    }

    // shuffle the array to make it extra random
    for (i = rgb.length - 1; i > 0; i--) {
      j = Math.floor(Math.random() * (i + 1));
      tmp = rgb[i];
      rgb[i] = rgb[j];
      rgb[j] = tmp;
    }

    return (rgb[0] + ', ' + rgb[1] + ', ' + rgb[2]);
  }
/*
 ***
 */

  /**
   * ###### Private function placeHighlightAtContainerCoords()
   * Given range coordinates, places highlight divs at the appropriate
   *     pixel coordinates on the page
   * @param {number} id Id suffix to give to the highlight
   * @param {string} coords Range coordinates at which to place the highlight
   * @param {number} ratio Indicates how far between yellow and red to color highlight
   *                       If ratio is false, a random color will be used
   */
  function placeHighlightAtContainerCoords(id, coords, ratio) {
    var text, txtCoord, currentTextCoord, length,
      coordsArray, coordsLength,
      normalizedCoords, normalLength,
      coord, normal,
      i, j, found,
      bgColor;

    ratio = ratio !== undefined ? ratio : 1;
    if (ratio === false) {
      bgColor = 'rgba(' + getRandomColor() + ', 0.25)';
    } else {
      if (ratio < 0 || ratio > 1) {
        ratio = 1;
      }
      bgColor = 'rgba(255, ' + Math.floor(255 * ratio) + ', 0, 0.25)';
    }

    text = highlighting.getTextAt(coords);

    if (text === false) {
      return false;
    }

    text = text.split('\n').join('');
    txtCoord = getTextCoordFromRangeCoord(coords);
    currentTextCoord = txtCoord.start;
    length = txtCoord.end - txtCoord.start;
    coordsArray = [];
    for (i = 0; i < length; i += 1) {
      highlighting.selectCoords(getRangeCoordFromTextCoord(currentTextCoord, currentTextCoord + 1));
      coordsArray[coordsArray.length] = getSelectionPixelCoords();
      highlighting.removeAllRanges();
      currentTextCoord += 1;
    }

    normalizedCoords = [];
    normalizedCoords[0] = {
      x: coordsArray[0].x,
      y: coordsArray[0].y,
      w: coordsArray[0].w,
      h: coordsArray[0].h
    };
    coordsLength = coordsArray.length;
    for (i = 1; i < coordsLength; i += 1) {
      found = false;
      coord = coordsArray[i];
      normalLength = normalizedCoords.length;
      for (j = 0; j < normalLength; j += 1) {
        normal = normalizedCoords[j];
        if (coord.y === normal.y) {
          // if they overlap but have the same y-coord
          if ((normal.x + normal.w) >= coord.x &&
              normal.x <= (coord.x + coord.w)) {
            normal.w += (coord.w - (Math.abs((normal.x + normal.w) - coord.x)));
            found = true;
            break;
          }
        }
      }
      if (!found) {
        normalizedCoords[normalLength] = coord;
      }
    }

    normalLength = normalizedCoords.length;
    for (i = 0; i < normalLength; i += 1) {
      placeHighlightAtPixelCoords(id + '-' + i, normalizedCoords[i], bgColor);
    }

    return true;
  }
/*
 ***
 */

  /**
   * ###### Public function onCreateSelection()
   * User-defined callback to be executed when a new selection is made
   */
  this.onCreateSelection = null;
/*
 ***
 */

  /**
   * ###### Public function setOnCreateSelection()
   * Sets the callback for when a new selection is made
   * @param {Function} onCreate The callback to execute
   */
  this.setOnCreateSelection = function(onCreate) {
    if (onCreate && typeof onCreate === 'function') {
      highlighting.onCreateSelection = onCreate;
    }
  };
/*
 ***
 */

  /**
   * ###### Public function init()
   * Initialize a new SelectionHighlighting object
   * @param {Function} onCreate A callback to execute when a selection is made (optional)
   */
  this.init = function(onCreate) {

    // reset selectableContainer and coordinates arrays
    selectableContainer = document.getElementById(selectableContainerId);
    selections = [];
    nodeCoords = [];
    textCoords = [];
    textCoord = 0;
    createdHeatMap = false;

    // remove any pre-existing highlight divs
    highlighting.removeAllHighlights();

    // make sure everything in the container has an id
    identifyAllElements(selectableContainer, 1);

    // create the coordinates mapping
    mapRangeCoordToTextCoord(selectableContainer);

    // set the container's mouseup to create a new selection, if necessary
    if (automaticallyRegisterEvent) {
      selectableContainer.addEventListener('mouseup', selectableMouseup, false);
      // selection was empty by time mouseup firing for touchscreen

    } else {
      // user must confirm selection when using touch screen
      document.addEventListener('selectionchange', handleSelectionChange, false);
    }

    highlighting.setOnCreateSelection(onCreate);
  };
/*
 ***
 */

  /**
   * ###### Public function destroy()
   * Remove all traces of this object having been on the page
   */
  this.destroy = function() {
    var selectionsLength, i;

    // remove any leftover highlights
    highlighting.removeAllHighlights();

    // remove all listeners from the selections list
    if (selections) {
      selectionsLength = selections.length;
    for (i = 0; i < selectionsLength; i += 1) {
      selections[i] = null;
    }
    }


    // remove the container's mouseup listener
    if (automaticallyRegisterEvent) {
      selectableContainer.removeEventListener('mouseup', selectableMouseup, false);
    }
    selectableContainer.removeEventListener('selectionchange', handleSelectionChange, false);

    highlighting = null;
  };
/*
 ***
 */

  /**
   * ###### Public function disableSelection()
   * Disallow the creation of new selections
   */
  this.disableSelection = function() {
    selectionDisabled = true;
  };
/*
 ***
 */

  /**
   * ###### Public function enableSelection()
   * Allow the creation of new selections
   */
  this.enableSelection = function() {
    selectionDisabled = false;
  };
/*
 ***
 */

  /**
   * ###### Public function loadSelections()
   * Load existing selections into the SelectionHighlighting object
   * @param {Array} loadedSelections The selections to load into the object
   */
  this.loadSelections = function(loadedSelections) {
    selections = loadedSelections;
  };
/*
 ***
 */

  /**
   * ###### Public function getId()
   * Returns the next available selection id
   */
  this.getId = function() {

    // selections are initially just ID'd based on their position in the array
    return selections.length;
  };
/*
 ***
 */

  /**
   * ###### Public function getSelection()
   * Returns the selection associated with the given id
   * @param {number} id The id of the selection to retrieve
   */
  this.getSelection = function(id) {
    if (id === undefined) {
      return null;
    }

    var i;
    for (i = 0; i < selections.length; i += 1) {
      if (selections[i] && selections[i].id === id) {
        return selections[i];
      }
    }
    return null;
  };
/*
 ***
 */

  /**
   * ###### Public function getText()
   * Returns the text associated with the selection
   * @param {number} id The id of the selection whose text is to be retrieved
   */
  this.getText = function(id) {
    var selection = highlighting.getSelection(id);

    if (selection === null) {
      return null;
    }
    return selection.text;
  };
/*
 ***
 */

  /**
   * ###### Public function getCoords()
   * Returns the coordinates associated with the selection
   * @param {number} id The id of the selection whose coordinates are to be retrieved
   */
  this.getCoords = function(id) {
    var selection = highlighting.getSelection(id);

    if (selection === null) {
      return null;
    }
    return selection.coords;
  };
/*
 ***
 */

  /**
   * ###### Public function getComments()
   * Returns the comments associated with the selection
   * @param {number} id The id of the selection whose comments are to be retrieved
   */
  this.getComments = function(id) {
    var selection = highlighting.getSelection(id);

    if (selection === null) {
      return null;
    }
    return selection.comments;
  };
/*
 ***
 */

  /**
   * ###### Public function createSelection()
   * Create a new selection with the given id
   * @param {number} id The id of the newly created selection object
   * @param {Event} event The mouse event that triggered the selection's creation
   */
  this.createSelection = function(id, event) {
    var results, text, coords;

    if (selectionDisabled) {
      return false;
    }

    event = event || window.event;
    results = highlighting.getSelectedTextAndCoords(event);

    if (results === undefined) {
      return false;
    }

    text = results.text;
    coords = results.coords;
    id = parseInt(id, 10);

    highlighting.removeAllHighlights();
    selections[id] = {
      id: id,
      text: text,
      coords: coords,
      comments: []
    };

    if (typeof highlighting.onCreateSelection === 'function') {
      highlighting.onCreateSelection(id);
    }

    return true;
  };
/*
 ***
 */

  /**
   * ###### Public function editSelection()
   * Currently does nothing
   * Meant for changing a selection's coordinates
   * @param {number} id The id of the selection to edit
   */
  this.editSelection = function(id) {
    // stub
    console.log('editing selection ' + id);
  };
/*
 ***
 */

  /**
   * ###### Public function highlightSelection()
   * Place a highlight over the selection
   * @param {number} id The id of the selection to highlight
   * @param {string} coords Coordinates at which to place the highlight (optional)
   */
  this.highlightSelection = function(id, coords) {

    // if the selection is already in the array
    if (selections[id]) {
      placeHighlightAtContainerCoords(id, selections[id].coords, 1);

    /*
     * selection isn't in the array, so use the given coordinates
     * and give the highlight the given id
     */
    } else {
      placeHighlightAtContainerCoords(id, coords, 1);
    }
  };
/*
 ***
 */

  /**
   * ###### Public function highlightAllSelections()
   * Highlight all current selections with random colors
   */
  this.highlightAllSelections = function() {
    for (var i = 0; i < selections.length; i++) {
      if (selections[i]) {
        placeHighlightAtContainerCoords(i, selections[i].coords, false);
      }
    }
  };
/*
 ***
 */

  /**
   * ###### Public function removeHighlight()
   * Removes only highlights on the container associated with given id
   * @param {string} id The id of the selection whose highlight should be removed
   */
  this.removeHighlight = function(id) {
    var matches = [], elements, length, i;

    // highlights are being attached directly to the container
    if (selectableContainer.style.position !== 'absolute') {
      elements = selectableContainer.getElementsByTagName('div');

    // highlights are being attached to document.body
    } else {
      elements = document.body.getElementsByTagName('div');
    }

    // loop through and collect the divs with the highlight prefix in the id
    length = elements.length;
    for (i = 0; i < length; i += 1) {
      if (elements[i].id.indexOf(highlightIdPrefix + id) === 0) {
        matches.push(elements[i]);
      }
    }

    // remove all the matched divs
    length = matches.length;
    for (i = 0; i < length; i += 1) {
      matches[i].parentNode.removeChild(matches[i]);
    }
  };
/*
 ***
 */

  /**
   * ###### Public function removeAllHighlights()
   * Removes all highlights from the container
   */
  this.removeAllHighlights = function() {
    var matches = [], elements, length, i;

    // highlights are being attached directly to the container
    if (selectableContainer.style.position !== 'absolute') {
      elements = selectableContainer.getElementsByTagName('div');

    // highlights are being attached to document.body
    } else {
      elements = document.body.getElementsByTagName('div');
    }

    // loop through and collect the divs with the highlight prefix in the id
    length = elements.length;
    for (i = 0; i < length; i += 1) {
      if (elements[i].id.indexOf(highlightIdPrefix) === 0) {
        matches.push(elements[i]);
      }
    }

    // remove all the matched divs
    length = matches.length;
    for (i = 0; i < length; i += 1) {
      matches[i].parentNode.removeChild(matches[i]);
    }
    createdHeatMap = false;
  };
/*
 ***
 */

  /**
   * ###### Public function getSelectedTextAndCoords()
   * To be called from a mouseup event
   * Returns the text and coordinates of the selected text
   * @param {Event} event The event that triggered the creation of the selection
   */
  this.getSelectedTextAndCoords = function(event) {
    var coords, text, nodes;

    // return if not a left click (can't select text with right click) unless touch screen
    if (automaticallyRegisterEvent) {
      if (event !== undefined && highlighting.getMouseButton(event) !== 'LEFT') {
        return;
      }
    }

    coords = highlighting.getSelectionContainerCoords();
    if (coords === undefined) {
      return; // don't try to make a selection with bad coordinates
    }

    text = buildStringFromRangeCoord(coords);
    if (text !== '') {
      nodes = coords.split(' ');
      if (!selectableContainer.contains(document.getElementById(nodes[0]))) {
        return; // don't try to make a selection starting outside of the submission container
      }
      if (!selectableContainer.contains(document.getElementById(nodes[3]))) {
        return; // don't try to make a selection ending outside of the submission container
      }

      return { text: text, coords: coords };
    }
  };
/*
 ***
 */

  /**
   * ###### Public function getSelectionContainerCoords()
   * Returns the range coordinates of the currently selected text
   */
  this.getSelectionContainerCoords = function() {
    var oRng, cstart, cend, startOffset, endOffset,
      s, child, e, ret, txtCoords;
    oRng = highlighting.getRange();
    if (!oRng || oRng.isCollapsed) {
      return;
    }

    cstart = oRng.startContainer;
    cend = oRng.endContainer;
    startOffset = oRng.startOffset;
    endOffset = oRng.endOffset;

    if (cend.nodeType !== TEXT_NODE && cend.nodeName.toLowerCase() !== 'img') {
      cend = cend.childNodes[endOffset];
      endOffset = 0;
    }

    if (cstart.parentNode.id === '' || cend.parentNode.id === '') {
      return;
    }

    // get position of start and end containers within their respective parents' childNodes collection
    s = 0;
    child = cstart;
    do {
      if (child.previousSibling !== null) {
        s += 1;
        child = child.previousSibling;
      }
    } while (child.previousSibling !== null);

    e = 0;
    child = cend;
    do {
      if (child.previousSibling !== null) {
        e += 1;
        child = child.previousSibling;
      }
    } while (child.previousSibling !== null);

    ret = cstart.parentNode.id + ' ' + s + ' ' + startOffset + ' ' + cend.parentNode.id + ' ' + e + ' ' + endOffset;
    txtCoords = getTextCoordFromRangeCoord(ret);
    if (txtCoords === undefined) {
      return;
    }

    if (txtCoords.end - txtCoords.start < 1) {
      return;
    }

    return ret;
  };
/*
 ***
 */

  /**
   * ###### Public function generateHeatMap()
   * Highlight all selections, shading with red based on number of overlaps
   */
  this.generateHeatMap = function() {
    var heat, selectionCoords, coords,
    minHeat, maxHeat,
    count = 0, heatRatio, arrSelections, tmpHighlightId,
    coordsLength, coordsEnd, heatLength, selectionsLength,
    i, j, s;

    if (!allElementsHaveBeenIdentified) {
      return false;
    }

    if (createdHeatMap) {
      highlighting.removeAllHighlights();
      createdHeatMap = false;
      return true;
    }

    heat = [];
    selectionCoords = getAllCoords();

    coordsLength = selectionCoords.length;
    for (i = 0; i < coordsLength; i += 1) {
      coords = getTextCoordFromRangeCoord(selectionCoords[i]);
      if (coords === undefined) {
        return false;
      }
      coordsEnd = coords.end;
      for (j = coords.start; j < coordsEnd; j += 1) {
        if (heat[j] === undefined) {
          heat[j] = 1;
        } else {
          heat[j] += 1;
        }
      }
    }

    // find the minimum heat, to scale the applied ratio down to the smallest shade being full yellow
    minHeat = 999999;
    maxHeat = 0;
    heatLength = heat.length;
    for (i = 1; i < heatLength; i += 1) {
      if (heat[i] !== undefined) {
        if (heat[i] < minHeat) {
          minHeat = heat[i];
        }
        if (heat[i] > maxHeat) {
          maxHeat = heat[i];
        }
      }
    }

    // need to not divide by zero when there's only one selection
    if (minHeat === maxHeat) {
      maxHeat = minHeat + 1;
    }

    // remove all existing highlights before adding the new ones
    highlighting.removeAllHighlights();
    count = 0;
    heatRatio = [];
    arrSelections = [];
    tmpHighlightId = highlightIdPrefix;
    highlightIdPrefix += heatIdPrefix;

    for (i = 0; i < heatLength; i += 1) {
      if (heat[i] !== undefined) {
        for (j = i; j < heatLength; j += 1) {
          if (heat[j + 1] !== heat[i]) {

            // ratio is 1 - (scaled heat / total selections)
            // allows for the shades of heat value to be an even step function
            arrSelections[count] = { id: count, coords: getRangeCoordFromTextCoord(i, j + 1) };
            heatRatio[count] = 1 - ((heat[i] - minHeat) / (maxHeat - minHeat));
            i = j;
            count += 1;
            break;
          }
        }
      }
    }

    selectionsLength = arrSelections.length;
    for (s = 0; s < selectionsLength; s += 1) {
      placeHighlightAtContainerCoords(s, arrSelections[s].coords, heatRatio[s]);
    }

    highlightIdPrefix = tmpHighlightId;

    createdHeatMap = true;
    return true;
  };
/*
 ***
 */

  /**
   * ###### Public function createSelectionWithoutMouse()
   * Programmatically creates a selection if there is text selected
   * @param {string} coords Coordinates to create selection with (optional)
   */
  this.createSelectionWithoutMouse = function(coords) {
    if (coords && coords !== undefined) {
      highlighting.selectCoords(coords);
    }
    highlighting.createSelection(highlighting.getId(), undefined, true);
  };
/*
 ***
 */
};

/**
 * ###### Public static function getRange()
 * Returns the selection object associated with currently highlighted text
 */
SelectionHighlighting.getRange = function() {
  if (window.getSelection) { // all browsers, except IE before version 9
    if (!window.getSelection().isCollapsed) {
      return window.getSelection().getRangeAt(0);
    }
  } else { // Internet Explorer
    return document.selection();
  }
};
/*
 ***
 */

/**
 * ###### Public static function removeAllRanges()
 * Remove all range objects from the page, unselecting all text
 */
SelectionHighlighting.removeAllRanges = function() {
  if (window.getSelection) {
    window.getSelection().removeAllRanges();
  } else if (document.selection) {
    document.selection.empty();
  }
};
/*
 ***
 */

/**
 * ###### Public static function getMouseButton()
 * Returns the mouse button that generated the event
 * @param {Event} event The event whose mouse button is to be checked
 */
SelectionHighlighting.getMouseButton = function(event) {
  var clickType = 'LEFT';

  event = event || window.event;

  if (event.which) {
    if (event.which === 3) {
      clickType = 'RIGHT';
    } else if (event.which === 2) {
      clickType = 'MIDDLE';
    }
  } else if (event.button) {
    if (event.button === 2) {
      clickType = 'RIGHT';
    } else if (event.button === 4) {
      clickType = 'MIDDLE';
    }
  }

  return clickType;
};
/*
 ***
 */

/**
 * ###### Public static function selectCoords()
 * Select the text on the page associated with the given range coordinates
 * @param {string} coord The range coordinates to select within the page
 */
SelectionHighlighting.selectCoords = function(coord) {
  var coords, eleStart, eleEnd, rangeObj;

  coords = coord.split(' ');

  if (coords.length < 6) {
    return false;
  }

  eleStart = document.getElementById(coords[0]);
  eleEnd = document.getElementById(coords[3]);

  if (!eleStart || eleStart === undefined) {
    return false;
  }
  if (!eleEnd || eleEnd === undefined) {
    return false;
  }
  if (document.createRange) { // all browsers, except IE before version 9
    rangeObj = document.createRange();
    rangeObj.setStart(eleStart.childNodes[parseInt(coords[1], 10)], parseInt(coords[2], 10));
    rangeObj.setEnd(eleEnd.childNodes[parseInt(coords[4], 10)], parseInt(coords[5], 10));
    SelectionHighlighting.removeAllRanges();
    window.getSelection().addRange(rangeObj);
  } else if (document.body.createTextRange) {  // Internet Explorer
    rangeObj = document.body.createTextRange();
    rangeObj.setStart(eleStart.childNodes[parseInt(coords[1], 10)], parseInt(coords[2], 10));
    rangeObj.setEnd(eleEnd.childNodes[parseInt(coords[4], 10)], parseInt(coords[5], 10));
    rangeObj.moveToBookmark(rangeObj);
    rangeObj.select();
  }

  return true;
};
/*
 ***
 */

/**
 * ###### Public static function getSelectedText()
 * Returns the selected text on the page
 */
SelectionHighlighting.getSelectedText = function() {
  var range, text;

  range = SelectionHighlighting.getRange();
  if (range && !range.isCollapsed) {
    text = range.toString();
  } else {
    text = '';
  }

  return text;
};
/*
 ***
 */

/**
 * ###### Public static function getTextAt()
 * Gets the text on the page at the given coordinates
 * @param {string} coords The range coords whose text is to be retrieved
 */
SelectionHighlighting.getTextAt = function(coords) {
  var text;

  // try to select the coordinates
  if (!SelectionHighlighting.selectCoords(coords)) {
    return false;
  }

  // get the selected text and unselect it
  text = SelectionHighlighting.getSelectedText();
  SelectionHighlighting.removeAllRanges();

  return text;
};

window.SelectionHighlighting = SelectionHighlighting;
}());
